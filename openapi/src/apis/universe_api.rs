/*
 * EVE Swagger Interface
 *
 * An OpenAPI for EVE Online
 *
 * The version of the OpenAPI document: 1.33
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`get_universe_ancestries`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseAncestriesError {
    Status400(models::BadRequest),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_asteroid_belts_asteroid_belt_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseAsteroidBeltsAsteroidBeltIdError {
    Status400(models::BadRequest),
    Status404(models::GetUniverseAsteroidBeltsAsteroidBeltIdNotFound),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_bloodlines`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseBloodlinesError {
    Status400(models::BadRequest),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_categories`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseCategoriesError {
    Status400(models::BadRequest),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_categories_category_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseCategoriesCategoryIdError {
    Status400(models::BadRequest),
    Status404(models::GetUniverseCategoriesCategoryIdNotFound),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_constellations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseConstellationsError {
    Status400(models::BadRequest),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_constellations_constellation_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseConstellationsConstellationIdError {
    Status400(models::BadRequest),
    Status404(models::GetUniverseConstellationsConstellationIdNotFound),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_factions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseFactionsError {
    Status400(models::BadRequest),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_graphics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseGraphicsError {
    Status400(models::BadRequest),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_graphics_graphic_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseGraphicsGraphicIdError {
    Status400(models::BadRequest),
    Status404(models::GetUniverseGraphicsGraphicIdNotFound),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseGroupsError {
    Status400(models::BadRequest),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_groups_group_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseGroupsGroupIdError {
    Status400(models::BadRequest),
    Status404(models::GetUniverseGroupsGroupIdNotFound),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_moons_moon_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseMoonsMoonIdError {
    Status400(models::BadRequest),
    Status404(models::GetUniverseMoonsMoonIdNotFound),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_planets_planet_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniversePlanetsPlanetIdError {
    Status400(models::BadRequest),
    Status404(models::GetUniversePlanetsPlanetIdNotFound),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_races`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseRacesError {
    Status400(models::BadRequest),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_regions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseRegionsError {
    Status400(models::BadRequest),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_regions_region_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseRegionsRegionIdError {
    Status400(models::BadRequest),
    Status404(models::GetUniverseRegionsRegionIdNotFound),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_stargates_stargate_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseStargatesStargateIdError {
    Status400(models::BadRequest),
    Status404(models::GetUniverseStargatesStargateIdNotFound),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_stars_star_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseStarsStarIdError {
    Status400(models::BadRequest),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_stations_station_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseStationsStationIdError {
    Status400(models::BadRequest),
    Status404(models::GetUniverseStationsStationIdNotFound),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_structures`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseStructuresError {
    Status400(models::BadRequest),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_structures_structure_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseStructuresStructureIdError {
    Status400(models::BadRequest),
    Status401(models::Unauthorized),
    Status403(models::Forbidden),
    Status404(models::GetUniverseStructuresStructureIdNotFound),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_system_jumps`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseSystemJumpsError {
    Status400(models::BadRequest),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_system_kills`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseSystemKillsError {
    Status400(models::BadRequest),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_systems`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseSystemsError {
    Status400(models::BadRequest),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_systems_system_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseSystemsSystemIdError {
    Status400(models::BadRequest),
    Status404(models::GetUniverseSystemsSystemIdNotFound),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_types`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseTypesError {
    Status400(models::BadRequest),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_universe_types_type_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUniverseTypesTypeIdError {
    Status400(models::BadRequest),
    Status404(models::GetUniverseTypesTypeIdNotFound),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_universe_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostUniverseIdsError {
    Status400(models::BadRequest),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_universe_names`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostUniverseNamesError {
    Status400(models::BadRequest),
    Status404(models::PostUniverseNamesNotFound),
    Status420(models::ErrorLimited),
    Status500(models::InternalServerError),
    Status503(models::ServiceUnavailable),
    Status504(models::GatewayTimeout),
    UnknownValue(serde_json::Value),
}


/// Get all character ancestries  --- Alternate route: `/legacy/universe/ancestries/`  Alternate route: `/v1/universe/ancestries/`  --- This route expires daily at 11:05
pub async fn get_universe_ancestries(configuration: &configuration::Configuration, accept_language: Option<&str>, datasource: Option<&str>, if_none_match: Option<&str>, language: Option<&str>) -> Result<Vec<models::GetUniverseAncestries200Ok>, Error<GetUniverseAncestriesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_accept_language = accept_language;
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;
    let p_language = language;

    let uri_str = format!("{}/universe/ancestries/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetUniverseAncestries200Ok&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetUniverseAncestries200Ok&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseAncestriesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get information on an asteroid belt  --- Alternate route: `/legacy/universe/asteroid_belts/{asteroid_belt_id}/`  Alternate route: `/v1/universe/asteroid_belts/{asteroid_belt_id}/`  --- This route expires daily at 11:05
pub async fn get_universe_asteroid_belts_asteroid_belt_id(configuration: &configuration::Configuration, asteroid_belt_id: i32, datasource: Option<&str>, if_none_match: Option<&str>) -> Result<models::GetUniverseAsteroidBeltsAsteroidBeltIdOk, Error<GetUniverseAsteroidBeltsAsteroidBeltIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_asteroid_belt_id = asteroid_belt_id;
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/universe/asteroid_belts/{asteroid_belt_id}/", configuration.base_path, asteroid_belt_id=p_asteroid_belt_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetUniverseAsteroidBeltsAsteroidBeltIdOk`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetUniverseAsteroidBeltsAsteroidBeltIdOk`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseAsteroidBeltsAsteroidBeltIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of bloodlines  --- Alternate route: `/legacy/universe/bloodlines/`  Alternate route: `/v1/universe/bloodlines/`  --- This route expires daily at 11:05
pub async fn get_universe_bloodlines(configuration: &configuration::Configuration, accept_language: Option<&str>, datasource: Option<&str>, if_none_match: Option<&str>, language: Option<&str>) -> Result<Vec<models::GetUniverseBloodlines200Ok>, Error<GetUniverseBloodlinesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_accept_language = accept_language;
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;
    let p_language = language;

    let uri_str = format!("{}/universe/bloodlines/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetUniverseBloodlines200Ok&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetUniverseBloodlines200Ok&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseBloodlinesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of item categories  --- Alternate route: `/legacy/universe/categories/`  Alternate route: `/v1/universe/categories/`  --- This route expires daily at 11:05
pub async fn get_universe_categories(configuration: &configuration::Configuration, datasource: Option<&str>, if_none_match: Option<&str>) -> Result<Vec<i32>, Error<GetUniverseCategoriesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/universe/categories/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;i32&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;i32&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseCategoriesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get information of an item category  --- Alternate route: `/legacy/universe/categories/{category_id}/`  Alternate route: `/v1/universe/categories/{category_id}/`  --- This route expires daily at 11:05
pub async fn get_universe_categories_category_id(configuration: &configuration::Configuration, category_id: i32, accept_language: Option<&str>, datasource: Option<&str>, if_none_match: Option<&str>, language: Option<&str>) -> Result<models::GetUniverseCategoriesCategoryIdOk, Error<GetUniverseCategoriesCategoryIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_category_id = category_id;
    let p_accept_language = accept_language;
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;
    let p_language = language;

    let uri_str = format!("{}/universe/categories/{category_id}/", configuration.base_path, category_id=p_category_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetUniverseCategoriesCategoryIdOk`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetUniverseCategoriesCategoryIdOk`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseCategoriesCategoryIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of constellations  --- Alternate route: `/legacy/universe/constellations/`  Alternate route: `/v1/universe/constellations/`  --- This route expires daily at 11:05
pub async fn get_universe_constellations(configuration: &configuration::Configuration, datasource: Option<&str>, if_none_match: Option<&str>) -> Result<Vec<i32>, Error<GetUniverseConstellationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/universe/constellations/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;i32&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;i32&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseConstellationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get information on a constellation  --- Alternate route: `/legacy/universe/constellations/{constellation_id}/`  Alternate route: `/v1/universe/constellations/{constellation_id}/`  --- This route expires daily at 11:05
pub async fn get_universe_constellations_constellation_id(configuration: &configuration::Configuration, constellation_id: i32, accept_language: Option<&str>, datasource: Option<&str>, if_none_match: Option<&str>, language: Option<&str>) -> Result<models::GetUniverseConstellationsConstellationIdOk, Error<GetUniverseConstellationsConstellationIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_constellation_id = constellation_id;
    let p_accept_language = accept_language;
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;
    let p_language = language;

    let uri_str = format!("{}/universe/constellations/{constellation_id}/", configuration.base_path, constellation_id=p_constellation_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetUniverseConstellationsConstellationIdOk`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetUniverseConstellationsConstellationIdOk`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseConstellationsConstellationIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of factions  --- Alternate route: `/dev/universe/factions/`  Alternate route: `/v2/universe/factions/`  --- This route expires daily at 11:05
pub async fn get_universe_factions(configuration: &configuration::Configuration, accept_language: Option<&str>, datasource: Option<&str>, if_none_match: Option<&str>, language: Option<&str>) -> Result<Vec<models::GetUniverseFactions200Ok>, Error<GetUniverseFactionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_accept_language = accept_language;
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;
    let p_language = language;

    let uri_str = format!("{}/universe/factions/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetUniverseFactions200Ok&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetUniverseFactions200Ok&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseFactionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of graphics  --- Alternate route: `/legacy/universe/graphics/`  Alternate route: `/v1/universe/graphics/`  --- This route expires daily at 11:05
pub async fn get_universe_graphics(configuration: &configuration::Configuration, datasource: Option<&str>, if_none_match: Option<&str>) -> Result<Vec<i32>, Error<GetUniverseGraphicsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/universe/graphics/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;i32&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;i32&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseGraphicsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get information on a graphic  --- Alternate route: `/dev/universe/graphics/{graphic_id}/`  Alternate route: `/legacy/universe/graphics/{graphic_id}/`  Alternate route: `/v1/universe/graphics/{graphic_id}/`  --- This route expires daily at 11:05
pub async fn get_universe_graphics_graphic_id(configuration: &configuration::Configuration, graphic_id: i32, datasource: Option<&str>, if_none_match: Option<&str>) -> Result<models::GetUniverseGraphicsGraphicIdOk, Error<GetUniverseGraphicsGraphicIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_graphic_id = graphic_id;
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/universe/graphics/{graphic_id}/", configuration.base_path, graphic_id=p_graphic_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetUniverseGraphicsGraphicIdOk`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetUniverseGraphicsGraphicIdOk`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseGraphicsGraphicIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of item groups  --- Alternate route: `/legacy/universe/groups/`  Alternate route: `/v1/universe/groups/`  --- This route expires daily at 11:05
pub async fn get_universe_groups(configuration: &configuration::Configuration, datasource: Option<&str>, if_none_match: Option<&str>, page: Option<i32>) -> Result<Vec<i32>, Error<GetUniverseGroupsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;
    let p_page = page;

    let uri_str = format!("{}/universe/groups/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;i32&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;i32&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseGroupsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get information on an item group  --- Alternate route: `/dev/universe/groups/{group_id}/`  Alternate route: `/legacy/universe/groups/{group_id}/`  Alternate route: `/v1/universe/groups/{group_id}/`  --- This route expires daily at 11:05
pub async fn get_universe_groups_group_id(configuration: &configuration::Configuration, group_id: i32, accept_language: Option<&str>, datasource: Option<&str>, if_none_match: Option<&str>, language: Option<&str>) -> Result<models::GetUniverseGroupsGroupIdOk, Error<GetUniverseGroupsGroupIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_group_id = group_id;
    let p_accept_language = accept_language;
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;
    let p_language = language;

    let uri_str = format!("{}/universe/groups/{group_id}/", configuration.base_path, group_id=p_group_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetUniverseGroupsGroupIdOk`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetUniverseGroupsGroupIdOk`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseGroupsGroupIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get information on a moon  --- Alternate route: `/legacy/universe/moons/{moon_id}/`  Alternate route: `/v1/universe/moons/{moon_id}/`  --- This route expires daily at 11:05
pub async fn get_universe_moons_moon_id(configuration: &configuration::Configuration, moon_id: i32, datasource: Option<&str>, if_none_match: Option<&str>) -> Result<models::GetUniverseMoonsMoonIdOk, Error<GetUniverseMoonsMoonIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_moon_id = moon_id;
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/universe/moons/{moon_id}/", configuration.base_path, moon_id=p_moon_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetUniverseMoonsMoonIdOk`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetUniverseMoonsMoonIdOk`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseMoonsMoonIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get information on a planet  --- Alternate route: `/legacy/universe/planets/{planet_id}/`  Alternate route: `/v1/universe/planets/{planet_id}/`  --- This route expires daily at 11:05
pub async fn get_universe_planets_planet_id(configuration: &configuration::Configuration, planet_id: i32, datasource: Option<&str>, if_none_match: Option<&str>) -> Result<models::GetUniversePlanetsPlanetIdOk, Error<GetUniversePlanetsPlanetIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_planet_id = planet_id;
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/universe/planets/{planet_id}/", configuration.base_path, planet_id=p_planet_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetUniversePlanetsPlanetIdOk`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetUniversePlanetsPlanetIdOk`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniversePlanetsPlanetIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of character races  --- Alternate route: `/dev/universe/races/`  Alternate route: `/legacy/universe/races/`  Alternate route: `/v1/universe/races/`  --- This route expires daily at 11:05
pub async fn get_universe_races(configuration: &configuration::Configuration, accept_language: Option<&str>, datasource: Option<&str>, if_none_match: Option<&str>, language: Option<&str>) -> Result<Vec<models::GetUniverseRaces200Ok>, Error<GetUniverseRacesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_accept_language = accept_language;
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;
    let p_language = language;

    let uri_str = format!("{}/universe/races/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetUniverseRaces200Ok&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetUniverseRaces200Ok&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseRacesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of regions  --- Alternate route: `/legacy/universe/regions/`  Alternate route: `/v1/universe/regions/`  --- This route expires daily at 11:05
pub async fn get_universe_regions(configuration: &configuration::Configuration, datasource: Option<&str>, if_none_match: Option<&str>) -> Result<Vec<i32>, Error<GetUniverseRegionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/universe/regions/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;i32&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;i32&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseRegionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get information on a region  --- Alternate route: `/legacy/universe/regions/{region_id}/`  Alternate route: `/v1/universe/regions/{region_id}/`  --- This route expires daily at 11:05
pub async fn get_universe_regions_region_id(configuration: &configuration::Configuration, region_id: i32, accept_language: Option<&str>, datasource: Option<&str>, if_none_match: Option<&str>, language: Option<&str>) -> Result<models::GetUniverseRegionsRegionIdOk, Error<GetUniverseRegionsRegionIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_region_id = region_id;
    let p_accept_language = accept_language;
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;
    let p_language = language;

    let uri_str = format!("{}/universe/regions/{region_id}/", configuration.base_path, region_id=p_region_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetUniverseRegionsRegionIdOk`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetUniverseRegionsRegionIdOk`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseRegionsRegionIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get information on a stargate  --- Alternate route: `/legacy/universe/stargates/{stargate_id}/`  Alternate route: `/v1/universe/stargates/{stargate_id}/`  --- This route expires daily at 11:05
pub async fn get_universe_stargates_stargate_id(configuration: &configuration::Configuration, stargate_id: i32, datasource: Option<&str>, if_none_match: Option<&str>) -> Result<models::GetUniverseStargatesStargateIdOk, Error<GetUniverseStargatesStargateIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_stargate_id = stargate_id;
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/universe/stargates/{stargate_id}/", configuration.base_path, stargate_id=p_stargate_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetUniverseStargatesStargateIdOk`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetUniverseStargatesStargateIdOk`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseStargatesStargateIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get information on a star  --- Alternate route: `/legacy/universe/stars/{star_id}/`  Alternate route: `/v1/universe/stars/{star_id}/`  --- This route expires daily at 11:05
pub async fn get_universe_stars_star_id(configuration: &configuration::Configuration, star_id: i32, datasource: Option<&str>, if_none_match: Option<&str>) -> Result<models::GetUniverseStarsStarIdOk, Error<GetUniverseStarsStarIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_star_id = star_id;
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/universe/stars/{star_id}/", configuration.base_path, star_id=p_star_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetUniverseStarsStarIdOk`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetUniverseStarsStarIdOk`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseStarsStarIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get information on a station  --- Alternate route: `/dev/universe/stations/{station_id}/`  Alternate route: `/v2/universe/stations/{station_id}/`  --- This route expires daily at 11:05
pub async fn get_universe_stations_station_id(configuration: &configuration::Configuration, station_id: i32, datasource: Option<&str>, if_none_match: Option<&str>) -> Result<models::GetUniverseStationsStationIdOk, Error<GetUniverseStationsStationIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_station_id = station_id;
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/universe/stations/{station_id}/", configuration.base_path, station_id=p_station_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetUniverseStationsStationIdOk`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetUniverseStationsStationIdOk`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseStationsStationIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List all public structures  --- Alternate route: `/dev/universe/structures/`  Alternate route: `/legacy/universe/structures/`  Alternate route: `/v1/universe/structures/`  --- This route is cached for up to 3600 seconds
pub async fn get_universe_structures(configuration: &configuration::Configuration, datasource: Option<&str>, filter: Option<&str>, if_none_match: Option<&str>) -> Result<Vec<i64>, Error<GetUniverseStructuresError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_datasource = datasource;
    let p_filter = filter;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/universe/structures/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_filter {
        req_builder = req_builder.query(&[("filter", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;i64&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;i64&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseStructuresError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns information on requested structure if you are on the ACL. Otherwise, returns \"Forbidden\" for all inputs.  --- Alternate route: `/legacy/universe/structures/{structure_id}/`  Alternate route: `/v1/universe/structures/{structure_id}/`  Alternate route: `/v2/universe/structures/{structure_id}/`  --- This route is cached for up to 3600 seconds
pub async fn get_universe_structures_structure_id(configuration: &configuration::Configuration, structure_id: i64, datasource: Option<&str>, if_none_match: Option<&str>, token: Option<&str>) -> Result<models::GetUniverseStructuresStructureIdOk, Error<GetUniverseStructuresStructureIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_structure_id = structure_id;
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;
    let p_token = token;

    let uri_str = format!("{}/universe/structures/{structure_id}/", configuration.base_path, structure_id=p_structure_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_token {
        req_builder = req_builder.query(&[("token", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetUniverseStructuresStructureIdOk`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetUniverseStructuresStructureIdOk`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseStructuresStructureIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the number of jumps in solar systems within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with jumps will be listed  --- Alternate route: `/legacy/universe/system_jumps/`  Alternate route: `/v1/universe/system_jumps/`  --- This route is cached for up to 3600 seconds
pub async fn get_universe_system_jumps(configuration: &configuration::Configuration, datasource: Option<&str>, if_none_match: Option<&str>) -> Result<Vec<models::GetUniverseSystemJumps200Ok>, Error<GetUniverseSystemJumpsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/universe/system_jumps/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetUniverseSystemJumps200Ok&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetUniverseSystemJumps200Ok&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseSystemJumpsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the number of ship, pod and NPC kills per solar system within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with kills will be listed  --- Alternate route: `/v2/universe/system_kills/`  --- This route is cached for up to 3600 seconds
pub async fn get_universe_system_kills(configuration: &configuration::Configuration, datasource: Option<&str>, if_none_match: Option<&str>) -> Result<Vec<models::GetUniverseSystemKills200Ok>, Error<GetUniverseSystemKillsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/universe/system_kills/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GetUniverseSystemKills200Ok&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GetUniverseSystemKills200Ok&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseSystemKillsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of solar systems  --- Alternate route: `/dev/universe/systems/`  Alternate route: `/legacy/universe/systems/`  Alternate route: `/v1/universe/systems/`  --- This route expires daily at 11:05
pub async fn get_universe_systems(configuration: &configuration::Configuration, datasource: Option<&str>, if_none_match: Option<&str>) -> Result<Vec<i32>, Error<GetUniverseSystemsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;

    let uri_str = format!("{}/universe/systems/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;i32&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;i32&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseSystemsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get information on a solar system.  --- Alternate route: `/dev/universe/systems/{system_id}/`  Alternate route: `/v4/universe/systems/{system_id}/`  --- This route expires daily at 11:05
pub async fn get_universe_systems_system_id(configuration: &configuration::Configuration, system_id: i32, accept_language: Option<&str>, datasource: Option<&str>, if_none_match: Option<&str>, language: Option<&str>) -> Result<models::GetUniverseSystemsSystemIdOk, Error<GetUniverseSystemsSystemIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_system_id = system_id;
    let p_accept_language = accept_language;
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;
    let p_language = language;

    let uri_str = format!("{}/universe/systems/{system_id}/", configuration.base_path, system_id=p_system_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetUniverseSystemsSystemIdOk`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetUniverseSystemsSystemIdOk`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseSystemsSystemIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of type ids  --- Alternate route: `/legacy/universe/types/`  Alternate route: `/v1/universe/types/`  --- This route expires daily at 11:05
pub async fn get_universe_types(configuration: &configuration::Configuration, datasource: Option<&str>, if_none_match: Option<&str>, page: Option<i32>) -> Result<Vec<i32>, Error<GetUniverseTypesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;
    let p_page = page;

    let uri_str = format!("{}/universe/types/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;i32&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;i32&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseTypesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get information on a type  --- Alternate route: `/dev/universe/types/{type_id}/`  Alternate route: `/legacy/universe/types/{type_id}/`  Alternate route: `/v2/universe/types/{type_id}/`  Alternate route: `/v3/universe/types/{type_id}/`  --- This route expires daily at 11:05
pub async fn get_universe_types_type_id(configuration: &configuration::Configuration, type_id: i32, accept_language: Option<&str>, datasource: Option<&str>, if_none_match: Option<&str>, language: Option<&str>) -> Result<models::GetUniverseTypesTypeIdOk, Error<GetUniverseTypesTypeIdError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_type_id = type_id;
    let p_accept_language = accept_language;
    let p_datasource = datasource;
    let p_if_none_match = if_none_match;
    let p_language = language;

    let uri_str = format!("{}/universe/types/{type_id}/", configuration.base_path, type_id=p_type_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }
    if let Some(param_value) = p_if_none_match {
        req_builder = req_builder.header("If-None-Match", param_value.to_string());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetUniverseTypesTypeIdOk`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetUniverseTypesTypeIdOk`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUniverseTypesTypeIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Resolve a set of names to IDs in the following categories: agents, alliances, characters, constellations, corporations factions, inventory_types, regions, stations, and systems. Only exact matches will be returned. All names searched for are cached for 12 hours  --- Alternate route: `/dev/universe/ids/`  Alternate route: `/legacy/universe/ids/`  Alternate route: `/v1/universe/ids/` 
pub async fn post_universe_ids(configuration: &configuration::Configuration, names: Vec<String>, accept_language: Option<&str>, datasource: Option<&str>, language: Option<&str>) -> Result<models::PostUniverseIdsOk, Error<PostUniverseIdsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_names = names;
    let p_accept_language = accept_language;
    let p_datasource = datasource;
    let p_language = language;

    let uri_str = format!("{}/universe/ids/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_language {
        req_builder = req_builder.query(&[("language", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_accept_language {
        req_builder = req_builder.header("Accept-Language", param_value.to_string());
    }
    req_builder = req_builder.json(&p_names);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PostUniverseIdsOk`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PostUniverseIdsOk`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostUniverseIdsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Resolve a set of IDs to names and categories. Supported ID's for resolving are: Characters, Corporations, Alliances, Stations, Solar Systems, Constellations, Regions, Types, Factions  --- Alternate route: `/dev/universe/names/`  Alternate route: `/legacy/universe/names/`  Alternate route: `/v2/universe/names/`  Alternate route: `/v3/universe/names/` 
pub async fn post_universe_names(configuration: &configuration::Configuration, ids: Vec<i32>, datasource: Option<&str>) -> Result<Vec<models::PostUniverseNames200Ok>, Error<PostUniverseNamesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ids = ids;
    let p_datasource = datasource;

    let uri_str = format!("{}/universe/names/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_datasource {
        req_builder = req_builder.query(&[("datasource", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_ids);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PostUniverseNames200Ok&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PostUniverseNames200Ok&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostUniverseNamesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

